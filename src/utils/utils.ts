export function pascalToKebab(value: string): string {
  return value.replace(/([a-z0â€“9])([A-Z])/g, "$1-$2").toLowerCase();
}

export function isSelector(value: any): value is string {
  return typeof value === "string" && value.length > 1;
}

export function isEmpty(value: any): boolean {
  return value === null || value === undefined;
}

export type SelectorCollection<T> = string | NodeListOf<Element> | T[];

export function ensureAllElements<T extends HTMLElement>(
  selectorElement: SelectorCollection<T>,
  context: HTMLElement = document as unknown as HTMLElement
): T[] {
  if (isSelector(selectorElement)) {
    return Array.from(context.querySelectorAll(selectorElement)) as T[];
  }
  if (selectorElement instanceof NodeList) {
    return Array.from(selectorElement) as T[];
  }
  if (Array.isArray(selectorElement)) {
    return selectorElement;
  }
  throw new Error(`Unknown selector element`);
}

export type SelectorElement<T> = T | string;

export function ensureElement<T extends HTMLElement>(
  selectorElement: SelectorElement<T>,
  context?: HTMLElement
): T {
  if (isSelector(selectorElement)) {
    const elements = ensureAllElements<T>(selectorElement, context);
    if (elements.length > 1) {
      console.warn(`selector ${selectorElement} return more then one element`);
    }
    if (elements.length === 0) {
      throw new Error(`selector ${selectorElement} return nothing`);
    }
    return elements.pop() as T;
  }
  if (selectorElement instanceof HTMLElement) {
    return selectorElement as T;
  }
  throw new Error("Unknown selector element");
}

export function cloneTemplate<T extends HTMLElement>(
  query: string | HTMLTemplateElement
): T {
  const template = ensureElement(query) as HTMLTemplateElement;
  if (!template.content.firstElementChild) {
    throw new Error(`Template ${query} has no content`);
  }
  return template.content.firstElementChild.cloneNode(true) as T;
}

export function bem(
  block: string,
  element?: string,
  modifier?: string
): { name: string; class: string } {
  let name = block;
  if (element) name += `__${element}`;
  if (modifier) name += `_${modifier}`;
  return {
    name,
    class: `.${name}`,
  };
}

export function getObjectProperties(
  target: object,
  filter?: (name: string, property: PropertyDescriptor) => boolean
): string[] {
  return Object.entries(
    Object.getOwnPropertyDescriptors(Object.getPrototypeOf(target))
  )
    .filter(([name, property]: [string, PropertyDescriptor]) =>
      filter ? filter(name, property) : name !== "constructor"
    )
    .map(([name]) => name);
}

export function setElementData<T extends Record<string, unknown> | object>(
  element: HTMLElement,
  data: T
) {
  for (const key in data) {
    element.dataset[key] = String(data[key]);
  }
}

export function getElementData<T extends Record<string, unknown>>(
  element: HTMLElement,
  scheme: Record<string, Function>
): T {
  const data: Partial<T> = {};
  for (const key in element.dataset) {
    data[key as keyof T] = scheme[key](element.dataset[key]);
  }
  return data as T;
}

export function isPlainObject(target: unknown): target is object {
  const prototype = Object.getPrototypeOf(target);
  return prototype === Object.getPrototypeOf({}) || prototype === null;
}

export function isBoolean(value: unknown): value is boolean {
  return typeof value === "boolean";
}

export function createElement<T extends HTMLElement>(
  tagName: keyof HTMLElementTagNameMap,
  props?: Partial<Record<keyof T, string | boolean | object>>,
  children?: HTMLElement | HTMLElement[]
): T {
  const element = document.createElement(tagName) as T;
  if (props) {
    for (const key in props) {
      const value = props[key];
      if (isPlainObject(value) && key === "dataset") {
        setElementData(element, value);
      } else {
        // @ts-expect-error fix indexing later
        element[key] = isBoolean(value) ? value : String(value);
      }
    }
  }
  if (children) {
    for (const child of Array.isArray(children) ? children : [children]) {
      element.append(child);
    }
  }
  return element;
}
